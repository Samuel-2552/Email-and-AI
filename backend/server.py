import os
from functools import wraps
import time
from utils.mock_db import db
from huggingface_hub import InferenceClient
from io import BytesIO
from flask import Flask, request, send_file, g, jsonify, url_for
from flask_cors import CORS
import matplotlib
from nylas import APIClient
from nylas.client.restful_models import Webhook
from nylas.services.tunnel import open_webhook_tunnel
from dotenv import load_dotenv
import pdfplumber
import torch
import easyocr
from transformers import BartForConditionalGeneration, BartTokenizer
import pandas as pd
import matplotlib.pyplot as plt
from docx import Document
import json
import seaborn as sns
import openpyxl
matplotlib.use('Agg')

# Load environment variables from the .env file
load_dotenv()


# Initialize the Nylas API client using the client id and secret specified in the .env file
nylas = APIClient(
    os.environ.get("NYLAS_CLIENT_ID"),
    os.environ.get("NYLAS_CLIENT_SECRET"),
    api_server = os.environ.get("NYLAS_API_SERVER") or "https://api.nylas.com"
)

# Before we start our backend, we should register our frontend
# as a redirect URI to ensure the auth completes
CLIENT_URI = 'http://localhost:3000'
updated_application_details = nylas.update_application_details(redirect_uris=[CLIENT_URI])
print('Application registered. Application Details: ', updated_application_details)

def run_webhook():
    """
    Run a webhook to receive real-time updates from the Nylas API.
    In this example, webhook open and error events and the messages received from the API are printed to the console.
    """
    def on_message(delta):
        """
        Raw webhook messages are parsed in the Nylas SDK and sent to this function as a delta
        """

        # Trigger logic on any webhook trigger Enum
        if delta["type"] == Webhook.Trigger.MESSAGE_CREATED:
            print("Message created")
            print(delta)
        if delta["type"] == Webhook.Trigger.ACCOUNT_CONNECTED:
            print("Account connected")
            print(delta)

    def on_open(ws):
        print("webhook tunnel opened")

    def on_error(ws, err):
        print("Error found")
        print(err)

    open_webhook_tunnel(
        nylas, {'on_message': on_message, 'on_open': on_open, 'on_error': on_error})


# Run the webhook
run_webhook()

# Initialize the Flask app
flask_app = Flask(__name__)

# Enable CORS for the Flask app
CORS(flask_app, supports_credentials=True)


@flask_app.route("/nylas/generate-auth-url", methods=["POST"])
def build_auth_url():
    """
    Generates a Nylas Hosted Authentication URL with the given arguments. 
    The endpoint also uses the app level constant CLIENT_URI to build the URL.

    This endpoint is a POST request and accepts the following parameters in the request body:
        success_url: The URL to redirect the user to after successful authorization.
        email_address: The email address of the user who is authorizing the app.

    Returns the generated authorization URL.
    """

    request_body = request.get_json()

    # Use the SDK method to generate a Nylas Hosted Authentication URL
    auth_url = nylas.authentication_url(
        (CLIENT_URI or "") + request_body["success_url"],
        login_hint=request_body["email_address"],
        scopes=['email.send', 'email.modify'],
        state=None,
    )

    return auth_url


@flask_app.route("/nylas/exchange-mailbox-token", methods=["POST"])
def exchange_code_for_token():
    """
    Exchanges an authorization code for an access token. 
    Once the access token is generated, it can be used to make API calls on behalf of the user. 
    For this example, we store the access token in our mock database.

    This endpoint is a POST request and accepts the following parameters: 
    
    Request Body:
        token: The authorization code generated by the Nylas Hosted Authentication.

    Returns a JSON object with the following information about the user:
        id: The identifier of the user in the database.
        emailAddress: The email address of the user.
    """

    request_body = request.get_json()

    # Use the SDK method to exchange our authorization code for an access token with the Nylas API
    access_token_obj = nylas.send_authorization(request_body["token"])

    # process the result and send to client however you want
    access_token = access_token_obj['access_token']
    email_address = access_token_obj['email_address']

    print('Access Token was generated for: ' + email_address)

    user = db.create_or_update_user(email_address, {
        'access_token': access_token,
        'email_address': email_address
    })

    return {
        'id': user['id'],
        'emailAddress': user['email_address']
    }


def is_authenticated(f):
    """
    A decorator that checks if the user is authenticated. 
    If the user is authenticated, the decorator sets the user's access token and returns the decorated function. 
    If the user is not authenticated, the decorator returns a 401 error. 

    This decorator is used for any endpoint that requires an access token to call the Nylas API.
    """

    @wraps(f)
    def decorator(*args, **kwargs):
        auth_headers = request.headers.get('Authorization')
        if not auth_headers:
            return 401

        # Find the user in the mock database
        user = db.find_user(auth_headers)
        if not user:
            return 401

        # Set the access token for the Nylas API client
        nylas.access_token = user['access_token']

        # Set the user in the Flask global object
        g.user = user

        return f(*args, **kwargs)
    return decorator


@flask_app.after_request
def after_request(response):
    """
    After request middleware that clear the Nylas access token after each request.
    """

    nylas.access_token = None

    return response

def get_file_icon(filename):
    extension = filename.split('.')[-1].lower()
    if extension == 'pdf':
        return 'fa fa-file-pdf-o'
    elif extension == 'csv':
        return 'fa fa-file-excel-o'
    elif extension in ('jpg', 'jpeg', 'png'):
        return 'fa fa-file-image-o'
    elif extension == 'xlsx':
        return 'fa fa-file-excel-o'
    elif extension == 'docx':
        return 'fa fa-file-word-o'
    elif extension == 'pptx':
        return 'fa fa-file-powerpoint-o'
    else:
        return 'fa fa-file'
@flask_app.route('/download')
@is_authenticated
def download():
    global file_data
    message = nylas.messages
    file = []
    for mess in message:
        file.append(mess.files)
    
    filenames = []
    ids = []

    for item in file:
        if type(item) is list:
            for sub_item in item:
                if type(sub_item) is dict:
                    filename = sub_item.get("filename")
                    id_value = sub_item.get("id")
                    # print(filename, id_value)
                    if filename is not None:
                        filenames.append(filename)
                        if id_value is not None:
                            ids.append(id_value)

    file_data = zip(filenames, ids)

    file_data_with_icons = [(filename, id, get_file_icon(filename)) for filename, id in file_data]

    # print(file_data_with_icons)

    # for i in range(len(ids)):
    #     file = nylas.files.get(ids[i])
    #     downloaded_file = file.download()

    #     # Create a subdirectory for each file
    #     file_directory = os.path.join("downloaded_files", str(i))
    #     os.makedirs(file_directory, exist_ok=True)

    #     # Get the filename
    #     filename = filenames[i]

    #     # Save the downloaded file inside the subdirectory
    #     file_path = os.path.join(file_directory, filename)

    #     with open(file_path, 'wb') as f:
    #         f.write(downloaded_file)
        
    return file_data_with_icons


@flask_app.route('/nylas/read-emails', methods=['GET'])
@is_authenticated
def read_emails():
    """
    Retrieve the first 5 threads of the authenticated account from the Nylas API.

    This endpoint is a GET request and accepts no parameters.

    The threads are retrieved using the Nylas API client, with the view set to "expanded".

    The threads are then returned as a JSON object.
    See our docs for more information about the thread object.
    https://developer.nylas.com/docs/api/#tag--Threads
    """

    # where() sets the query parameters for the request
    # all() executes the request and return the results
    res = nylas.threads.where(limit=5, view="expanded").all()

    # enforce_read_only=False is used to return the full thread objects
    res_json = [item.as_json(enforce_read_only=False) for item in res]

    return res_json


@flask_app.route('/nylas/message', methods=['GET'])
@is_authenticated
def get_message():
    """
    Retrieve a message from the Nylas API.

    This endpoint is a GET request and accepts the following:
    
    Query Parameters:
        'id': The identifier of the message to retrieve.

    The message is retrieved using the Nylas API client by id, with the view set to "expanded".

    The message is then returned as a JSON object.
    See our docs for more information about the message object.
    https://developer.nylas.com/docs/api/#tag--Messages
    """

    message_id = request.args.get('id')

    # where() sets the query parameters for the request
    # get() executes the request and return the results
    message = nylas.messages.where(view="expanded").get(message_id)

    # enforce_read_only=False is required to return the full message object
    return message.as_json(enforce_read_only=False)


@flask_app.route('/nylas/file', methods=['GET'])
@is_authenticated
def download_file():
    """
    Retrieve and download a file from the Nylas API.

    This endpoint is a GET request and accepts the following:

    Query Parameters:
        id: The identifier of the file to download.

    The file metadata is retrieved using the Nylas API client.
    A second request is sent to the API and the file is downloaded.

    Returns the file with metadata to the client for download.

    See our docs for more information about the file object.
    https://developer.nylas.com/docs/api/#tag--Files
    """

    file_id = request.args.get('id')
    file_metadata = nylas.files.get(file_id)

    file = file_metadata.download()

    return send_file(BytesIO(file), download_name=file_metadata.filename, mimetype=file_metadata.content_type, as_attachment=True)


@flask_app.route('/nylas/send-email', methods=['POST'])
@is_authenticated
def send_email():
    """
    Sends an email on behalf of the user. 
    The endpoint also uses the user's access token to send the email.

    This endpoint is POST request and accepts the following parameters:
    
    Request Body:
        to: The email address of the recipient.
        body: The body of the email.

    Returns the message object from the Nylas API. 
    See our docs for more information about the message object.
    https://developer.nylas.com/docs/api/#tag--Messages
    """

    user = g.user
    request_body = request.get_json()

    # Create a draft object
    draft = nylas.drafts.create()

    # Set draft properties after initialization
    draft['subject'] = request_body['subject']
    draft['to'] = [{'email': request_body['to']}]
    draft['body'] = request_body['body']
    draft['from'] = [{'email': user['email_address']}]

    # Send the draft
    message = draft.send()

    # Return the sent message object
    return message

@flask_app.route('/process_file', methods=['GET'])
@is_authenticated
def process_file():
    # Get the file ID and filename from the request
    print("hello")
    file_id = request.args.get('id')
    filename = request.args.get('filename')

    print(filename, file_id)

    file = nylas.files.get(file_id)
    downloaded_file = file.download()

    file_directory = os.path.join("files")

    file_path = os.path.join(file_directory, filename)

    with open(file_path, 'wb') as f:
        f.write(downloaded_file)

    extension = filename.split('.')[-1].lower()

    if extension == 'pdf':
        text=pdf(filename)
        print(text)
        summary = summarization(text)
        print(summary)
        return jsonify({filename: summary})
        # return summary
    
    elif extension in ('jpg', 'jpeg', 'png'):
        text=image(filename)
        print(text)
        summary = summarization(text)
        print(summary)
        return jsonify({filename: summary})
    
    elif extension == 'xlsx':
        
        df_excel = pd.read_excel("files/" + filename)
        summary_stats = df_excel.describe()
        # Create a bar plot
        summary_stats.plot(kind='bar', figsize=(10, 6))
        plt.title('Summary Statistics')
        plt.xlabel('Statistics')
        plt.ylabel('Values')
        plt.legend(loc='upper right')
        plt.grid(axis='y', linestyle='--', alpha=0.7)
        plt.tight_layout()

        # Save the plot as an image (e.g., PNG)
        plt.savefig('static/summary_statistics.png')
        image_url = url_for('static', filename='summary_statistics.png')
        # Close the plot to release resources (optional)
        plt.close()
        cb = int(time.time())
        return jsonify({filename:f"http://127.0.0.1:9000/static/summary_statistics.png?cb={cb}", 'isImage':True})
    
    elif extension == 'docx':
        filename = "files/" + filename
        doc = Document(filename)
        text = ''

        for paragraph in doc.paragraphs:
            text += paragraph.text
        
        print(text)

        # summary = summarization(text)
        # print(summary)

        return jsonify({filename: text})
    


    # Assume you have some processing logic here
    # For demonstration, we'll just store the filename as content

    # Return the processed content as a response with the filename inserted
    return jsonify(f'Summary of the file: {summary}')

def image(filename):
    filename = "files/" + filename
    reader = easyocr.Reader(['en'])  # Replace 'en' with the language you need
    result = reader.readtext(filename)
    text=''
    for detection in result:
        print(detection[1])
        text = text + detection[1]

    # print(result)
    return text

def pdf(filename):
    
    filename = "files/" + filename
    # Open the PDF file
    with pdfplumber.open(filename) as pdf:
        # Initialize an empty string to store extracted text
        text = ''

        # Iterate through each page and extract text
        for page in pdf.pages:
            text += page.extract_text()
    return text

def summarization(text):
    # # Load the pre-trained BART model and tokenizer
    # model_name = "facebook/bart-large-cnn"
    # model = BartForConditionalGeneration.from_pretrained(model_name)
    # tokenizer = BartTokenizer.from_pretrained(model_name)

    # # Tokenize and encode the input text
    # inputs = tokenizer(text, return_tensors="pt", max_length=1024, truncation=True, padding=True)

    # # Generate the summary
    # summary_ids = model.generate(inputs["input_ids"], num_beams=4, min_length=30, max_length=200, early_stopping=True)

    # # Decode the generated summary
    # summary = tokenizer.decode(summary_ids[0], skip_special_tokens=True)
    client = InferenceClient()
    summary = client.summarization(text)

    # Print the summary
    print(summary)
    return summary

